--// Services
local DataStoreService = game:GetService("DataStoreService") -- Access Roblox's DataStore for saving/loading data
local RunService = game:GetService("RunService") -- Allows connection to game loop (like Heartbeat)
local TweenService = game:GetService("TweenService") -- Used to animate object movement
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Shared storage between client and server
local Players = game:GetService("Players") -- Access all players in the game

--// DataStores
local PetsDS = DataStoreService:GetDataStore("Pet") -- Pet DataStore for saving player pet info
local CoinsDS = DataStoreService:GetDataStore("Coins") -- Coins DataStore for saving player coins

--// Runtime Tables
local collectingCoin: { [number]: Instance } = {} -- Keeps track of which coin each player is collecting
local damageConns: { [number]: RBXScriptConnection } = {} -- Stores damage connections for each player

--// Configurations
local petPowers = { -- Defines damage strength for each pet type
	Cat = 1,
	Wolf = 2,
	Dragon = 5,
	Phoenix = 10
}
local coinRewards = { -- Coin reward value by type
	Coin = 5,
	CoinStack = 10,
	CoinPile = 20
}

--// Folders
local coinSpawns = workspace:WaitForChild("Spawns") -- Folder containing coin spawn points
local clickables = workspace:WaitForChild("Clickables") -- Folder to hold active coin models

--// Helper: Load data safely
local function LoadData(ds: DataStore, key: string | number, fallback: any): any
	local success, result = pcall(function()
		return ds:GetAsync(key) -- Try to get saved data
	end)
	return (success and result) or fallback -- Return result or fallback if failed
end

--// Helper: Save data safely
local function SaveData(ds: DataStore, key: string | number, value: any)
	pcall(function()
		ds:SetAsync(key, value) -- Try to save data
	end)
end

--// Helper: Create pet
local function CreatePetForCharacter(player: Player, petName: string): Model?
	local petModel = ReplicatedStorage:WaitForChild("Pets"):FindFirstChild(petName) -- Find pet model
	if petModel and player.Character then
		local clone = petModel:Clone() -- Clone pet
		clone.Name = player.Name .. "PET"
		clone.Parent = player.Character -- Parent to character
		return clone
	end
	return nil -- Return nil if failed
end

--// Helper: Pet follows player
local function PlayPetFollowTween(petModel: Model, targetCFrame: CFrame): Tween
	local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut) -- Animation settings
	return TweenService:Create(petModel.PrimaryPart, tweenInfo, { CFrame = targetCFrame }) -- Create tween
end

--// Helper: Stop collecting coins
local function StopCollecting(player: Player, coin: Instance?)
	local userId = player.UserId
	if damageConns[userId] then
		damageConns[userId]:Disconnect() -- Stop damage loop
		damageConns[userId] = nil
	end
	collectingCoin[userId] = nil -- Stop tracking coin
	if coin and coin:IsDescendantOf(workspace) then
		coin:SetAttribute("Owner", nil) -- Unclaim coin
	end
end

--// Helper: Handle coin destruction
local function UpdateCoinHealthAndReward(coin: Instance)
	if coin:FindFirstChild("Health") and coin.Health.Value <= 0 then
		local ownerId = coin:GetAttribute("Owner")
		if not ownerId then return end -- No owner

		local player = Players:GetPlayerByUserId(ownerId)
		local reward = coinRewards[coin.Name] or 0 -- Reward amount
		local spawnPoint = coin:FindFirstChild("Spawn") and coin.Spawn.Value -- Get spawn point

		if spawnPoint then
			spawnPoint.Occupied.Value = false -- Mark spawn as free
		end
		coin:Destroy() -- Remove coin

		if player and player:FindFirstChild("Coins") then
			player.Coins.Value += reward -- Give coins
		end
	end
end

--// Helper: Setup coin logic
local function SetupCoin(coin: Model)
	local clickDetector = coin:FindFirstChildWhichIsA("ClickDetector")
	if not clickDetector then return end

	coin:SetAttribute("Owner", nil) -- Reset owner

	coin.Health.Changed:Connect(function()
		UpdateCoinHealthAndReward(coin) -- Watch for coin break
	end)

	clickDetector.MouseClick:Connect(function(player)
		if coin:GetAttribute("Owner") and coin:GetAttribute("Owner") ~= player.UserId then return end -- Ignore if owned

		local pet = player.Character and player.Character:FindFirstChild(player.Name .. "PET")
		if not pet then return end

		local display = coin:WaitForChild("Display")
		local healthText = display:WaitForChild("Health")

		if not collectingCoin[player.UserId] then
			collectingCoin[player.UserId] = coin -- Start collecting
			coin:SetAttribute("Owner", player.UserId) -- Set owner
			display.Enabled = true -- Show health
			healthText.Text = tostring(coin.Health.Value)
			
			local sound = coin:FindFirstChild("ClickSound")
			if sound then 
				sound:Play() 
			end

			local lastDamage = 0
			damageConns[player.UserId] = RunService.Heartbeat:Connect(function(dt)
				if not coin:IsDescendantOf(workspace) or not coin:GetAttribute("Owner") then
					StopCollecting(player, coin)
					return
				end

				lastDamage += dt
				local coinPos = coin.PrimaryPart.Position
				local petPart = pet.PrimaryPart
				local offsetPos = coinPos + (petPart.CFrame.LookVector * -5)

				petPart.CFrame = CFrame.new(offsetPos, coinPos) -- Move pet

				if lastDamage >= 1 then
					lastDamage = 0
					if coin:FindFirstChild("Health") then
						coin.Health.Value -= petPowers[player.Pet.Value] or 1 -- Deal damage
						healthText.Text = tostring(coin.Health.Value)
					end
				end
			end)
		elseif collectingCoin[player.UserId] == coin then
			StopCollecting(player, coin) -- Stop if clicked again
			display.Enabled = false
		end
	end)
end

--// Helper: Spawn coins in empty spots
local function SpawnCoin()
	for _, spawnPoint in coinSpawns:GetChildren() do
		if spawnPoint:IsA("BasePart") and not spawnPoint.Occupied.Value then
			spawnPoint.Occupied.Value = true -- Mark used
			local coinTypes = { "Coin", "CoinPile", "CoinStack" }
			local chosenType = coinTypes[math.random(1, #coinTypes)]
			local template = ReplicatedStorage.Coins:FindFirstChild(chosenType)

			if template then
				local coin = template:Clone()
				coin.Spawn.Value = spawnPoint
				coin:PivotTo(spawnPoint.CFrame) -- Move to position
				coin.Parent = clickables -- Add to world
				SetupCoin(coin) -- Setup logic
			end
			break -- Only spawn one per call
		end
	end
end

--// Helper: Player setup
local function SetupPlayer(player: Player)
	local pet = Instance.new("StringValue")
	pet.Name = "Pet"
	pet.Value = LoadData(PetsDS, player.UserId, "Cat") -- Load pet or default
	pet.Parent = player

	pet.Changed:Connect(function()
		SaveData(PetsDS, player.UserId, pet.Value) -- Save on change
	end)

	player.CharacterAdded:Connect(function(character)
		local model = CreatePetForCharacter(player, pet.Value)
		if not model then return end

		local root = character:WaitForChild("HumanoidRootPart")
		local busy = false

		RunService.Heartbeat:Connect(function()
			if not busy and not collectingCoin[player.UserId] then
				busy = true
				local tween = PlayPetFollowTween(model, root.CFrame * CFrame.new(0, 0, 5)) -- Pet follows player
				tween:Play()
				tween.Completed:Once()
				tween:Destroy()
				busy = false
			end
		end)
	end)

	local gui = player:WaitForChild("PlayerGui"):WaitForChild("ScreenGui")
	local label = gui:WaitForChild("Coins")

	local coins = Instance.new("NumberValue")
	coins.Name = "Coins"
	coins.Value = LoadData(CoinsDS, player.UserId, 0) -- Load coins or default
	coins.Parent = player

	label.Text = tostring(coins.Value)

	coins.Changed:Connect(function()
		SaveData(CoinsDS, player.UserId, coins.Value) -- Save coins
		label.Text = tostring(coins.Value) -- Update UI
	end)
end

--// Player join detection
Players.PlayerAdded:Connect(SetupPlayer) -- Call SetupPlayer when player joins

--// Coin spawner loop
task.spawn(function()
	while true do
		task.wait(5) -- Wait 5 seconds
		SpawnCoin() -- Try to spawn a coin
	end
end)
